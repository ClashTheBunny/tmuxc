#!/usr/bin/env perl

use strict;
use warnings;

use Time::HiRes;
use Getopt::Long qw(:config no_ignore_case);
use Sys::Hostname;
use IPC::Open2;
use Time::HiRes qw( gettimeofday );
use POSIX qw ( mkfifo setsid );
use Fcntl;
use FindBin qw ($RealScript $RealBin);
use File::Basename;
use Pod::Usage;
use Sys::Syslog qw(:standard :macros);

use Data::Dumper;
$Data::Dumper::Indent   = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Purity   = 1;

# Forward declare all subs
sub LoadConfig;
sub InjectCommand;
sub shellQuote;
sub buildCommandRefArray;
sub buildCommand;
sub spawnTerm;
sub checkIfBlacklisted;
sub ListWindows;
sub BulkDetach;
sub BulkSpawn;
sub ClientMap;
sub CleanExit;
sub InstanceCheck;
sub Launcher;
sub Menu;
sub PauseSelf;
sub KillSelf;
sub Log;


# Add signal handlers, load our config on start
BEGIN {
  $SIG{INT}   = \&CleanExit;
  $SIG{TERM}  = \&CleanExit; 
  $SIG{HUP}   = \&LoadConfig;
  $SIG{PIPE}  = sub {};
}

my (
  $config,  $configfile,   $pause,
  $v,       $noclean,
  $host,    $help,         $passcount,
  %publicCommands, %defaultOptions,
  %cli, %mapping, %commandParse, %commandText
);

$configfile = join('/', ( $ENV{'HOME'}, qw(.tmuxc.conf) ) );
$noclean    = 1;
$v          = LOG_NOTICE;
$pause      = 0;
$passcount  = 0;

GetOptions(
  "host|h=s"      => \$cli{host},
  "session|s=s"   => \$cli{session},
  "background|b"  => \$cli{background},
  "config|c=s"    => \$configfile,
  "detach|d"      => \$cli{detach},
  "verbose|v+"    => \$v,
  "killrc|k"      => \$cli{killrc},
  "pauserc|P"     => \$cli{pauserc},
  "reconnect|R"   => \$cli{reconnect},
  "closeas|C"     => \$cli{closeas},
  "syslog|S=s"    => \$cli{syslog},
  "exitlast|E"    => \$cli{exitlast},
  "new|n"         => sub { LoadConfig; InjectCommand("new-window -d"); },
  "launcher|l"    => sub { LoadConfig; Launcher; },
  "menu|m"        => sub { LoadConfig; Menu; },
  "exit|e"        => sub { LoadConfig; InjectCommand("tmuxc KillSelf"); },
  "pause|p"       => sub { LoadConfig; InjectCommand("tmuxc PauseSelf"); },
  "raw|r=s"       => sub { my (undef, $cmd) = @_; LoadConfig; InjectCommand($cmd); },
  "help|?"        => \$help,
);

# Set our log_level based on verbose flags
$cli{log_level} = $v;

pod2usage( -verbose => 2 ) if $help;

LoadConfig;

# Check if an instance for this specific host and session is running
if ( -f $config->{pidfile} ) {
  open PID, '<', $config->{pidfile};
  my $pid = <PID>;
  close PID;
  if ( kill( 0, $pid ) ) {
    Log(LOG_DEBUG, "$config->{pidfile} exists, and is running");
    die "$config->{pidfile} exists, and pid $pid is running\n";
  }
}

# Double fork
if ($config->{background}) {
  my $fpid = fork;
  exit if $fpid;    # kill first parent
  open STDIN,  '/dev/null';
  open STDOUT, '>/dev/null';
  open STDERR, '>/dev/null';
  setsid();
  $fpid = fork;
  exit if $fpid;
}

unless ( $config->{log_facility} eq '' ) {
  openlog( $RealScript, "nofatal,ndelay,pid", $config->{log_facility} );
  setlogmask( LOG_UPTO($config->{log_level}) );
}

if ($config->{log_level} == LOG_NOTICE) {
  close STDERR;
}

$|++;

# Write our PID to a file, regardless of fg or bg state
open PID, '>', $config->{pidfile};
print PID $$;
close PID;

# Disable the noclean flag, now that we've written a PID to disk
$noclean = 0;

Log(LOG_NOTICE, "tmuxc running as PID $$");

while (1) {

  %mapping = ();
  my @cmd;

  # Remote host mode!
  # Check if we have a ControlMaster session, create it if not
  if (defined($host)) {
    @cmd = buildCommand( undef, [
        qq(ssh -q -O check),
        qq(-o ConnectTimeout=$config->{conn_timeout}),
        qq(-o ControlPath=$config->{temp}ssh/%C 2>/dev/null),
        $host ]);
    qx(@cmd);

    # Master isn't running, start up a new ControlMaster
    if ( ( $? >> 8 ) != 0 ) {
      Log(LOG_DEBUG, "ControlMaster for $host not running, creating one");
      @cmd = buildCommand( undef, [ qq(ssh),
        qq(-o ConnectTimeout=$config->{conn_timeout}),
        qq(-o ServerAliveInterval=$config->{alive_interval}),
        qq(-o ServerAliveCountMax=$config->{alive_count}),
        qq(-o ControlPersist=$config->{persist}),
        qq(-o ControlPath=$config->{temp}ssh/%C),
        qq(-o ControlMaster=yes),
        qq(@{ $config->{ssh_args} }),
        qq(-f -N),
        $host ] );
      qx(@cmd);

      if ( ( $? >> 8 ) != 0 ) {
        Log(LOG_INFO, "Retrying connection to $host in 5 seconds");
        sleep 5;
        if ( $config->{reconnect} ) {
          goto MAINEND;
        }
      }
    }
  }

  # Tell the remote instance to kill itself
  if (($config->{killrc}) and ($host)) {
    Log(LOG_INFO, "Killing remote tmuxc instance");
    Log(LOG_DEBUG, \@cmd);
    my $control = join('-', qw(localhost), $config->{session});
    @cmd = buildCommand( $cli{host}, [ qw(tmuxc -h localhost -s), $config->{session}, qw(-e) ]);
    qx(@cmd);
  # Tell the remote instance to pause itself 
  } elsif (($config->{pauserc}) and ($host)) { 
    Log(LOG_INFO, "Pausing remote tmuxc instance");
    Log(LOG_DEBUG, \@cmd);
    my $control = join('-', qw(localhost), $config->{session});
    @cmd = buildCommand( $cli{host}, [ qw(tmuxc -h localhost -s), $config->{session}, qw(-p) ]);
    qx(@cmd);
  }

  # Check if session exists
  @cmd = buildCommand( $host, [ $config->{tmux_bin}, qw(has-session -t), $config->{session}, ] );
  qx(@cmd);

  # If the session doesn't exist, use the user-defined method if it exists, else make a new empty one
  if ( ( $? >> 8 ) != 0 ) {
    # Second time through the loop and our session doesn't exist, so exit instead of creating a new session
    last if ( ( $config->{exitlast} ) and ( $passcount ) );

    my $chost = $config->{chost};
    my $sess  = $config->{session};
    my $initialize = $config->{hosts}{$chost}{$sess}{initialize} || [ $config->{tmux_bin}, qw(new-session -d -s), $sess ];

    Log(LOG_INFO, "Initializing session: $sess");

    @cmd = buildCommand( $host, $initialize );
    qx(@cmd);

    if ( ( $? >> 8 ) != 0 ) {
      die "Session initilization failed, exiting";
    }
  }

  # Check if control session exists
  @cmd = buildCommand( $host, [ $config->{tmux_bin}, qw(has-session -t), $config->{control}, ] );
  qx(@cmd);

  if ( ( $? >> 8 ) == 0 ) {
    Log(LOG_DEBUG, "Killing existing control session");
    @cmd = buildCommand( $host, [ $config->{tmux_bin}, qw(kill-session -t), $config->{control}, ] );
    qx(@cmd);
  }

  # Create control clone session
  @cmd = buildCommand(
    $host,
    [
      $config->{tmux_bin},
      qw(new-session -d -t), $config->{session},
      qw(-s),                $config->{control},
    ]
  );

  qx(@cmd);

  # Attach to control session in control mode
  @cmd = buildCommand( $host, [ $config->{tmux_bin}, qw(-C attach-session -t), $config->{control}, ] );

  my $sess = $config->{session};
  my ( $pid, $child_out, $child_in );
  my $blockCapture = 0;
  my ( @block, $function, $result );

  $pid = open2( $child_out, $child_in, @cmd );

  # Seed our initial list of windows
  print $child_in $commandText{'ListWindows'};

  # Detach then spawn windows, otherwise spawn windows
  if ($config->{detach}) {
    print $child_in $commandText{'BulkDetach'};
    print $child_in $commandText{'BulkSpawn'};
    print $child_in $commandText{'ClientMap'};
  }
  else {
    print $child_in $commandText{'BulkSpawn'};
    print $child_in $commandText{'ClientMap'};
  }

  # Create our command channel
  unless ( -p $config->{command} ) {
    unlink $config->{command};
    mkfifo( $config->{command}, 0700 );
  }

  # Open it up non-blocking, read-only
  sysopen( CONTROL_FIFO, $config->{command}, O_NONBLOCK | O_RDONLY );

  # Install our USR1 handler to process anything in the FIFO
  $SIG{USR1} = sub {
    my @commands = <CONTROL_FIFO>;
    Log(LOG_DEBUG, "Processing commands in FIFO handler:");
    Log(LOG_DEBUG, \@commands);
    foreach my $line (@commands) {
      if ($pause) {
        next unless ($line =~ m/tmuxc PauseSelf/);
      }
      # Lines prefixed with tmuxc hit our internal command dispatcher
      if ( $line =~ m/^tmuxc\s(.*)/ ) {
        # The command causes tmux to print a block output, which we later parse
        if ( exists( $commandText{$1} ) ) {
          print $child_in $commandText{$1};
        } elsif ( exists( $publicCommands{$1} ) ) {
          # Execute a command directly with no required input
          $publicCommands{$1}->();
        } else {
          Log(LOG_DEBUG, "FIFO Handler: Unknown command $1");
        }
      } else {
        # everything else is assumed to be a raw tmux command
        print $child_in "$line\n";
      }
    }
  };

  # Main event loop
  while ( my $line = <$child_out> ) {
    next if $pause;
    next if $line =~ m/^\%output/;
    $line =~ s/\r\n/\n/g;
    Log(LOG_DEBUG, "$line");

    # Trigger block capture mode
    if ( $line =~ m/^\%begin/ ) {
      $blockCapture = 1;
      next;
    }

    # Blocks can end with either end or error
    if ( $line =~ m/^\%end/ ) {
      $blockCapture = 0;
      next unless defined($function);
      Log(LOG_DEBUG, "Captured $function block");

      my $cmd = $function;
      if ( exists( $commandParse{$cmd} ) ) {
        $commandParse{$cmd}->( \@block, $child_in );
      }
      else {
        Log(LOG_DEBUG, "No handler for $cmd");
      }
      @block    = ();
      $function = undef;
      next;
    }

    # Push the line to the current block
    if ($blockCapture) {
      ( $function, $result ) = split( /:/, $line );
      chomp($result);
      push @block, $result;
      next;
    }

    # This event produces a TON of spam
    # Linked sessions result in every session producing this, with out saying where it comes from
    # Multiple conditions are used to keep from spawning an infinite sequence of windows
    if ( $line =~ m/^\%window-add\s(\@\d+)/ ) {
      if ( exists $mapping{windows}{$1}{'pending'} ) {

        # This is removed only by spawnTerm
        Log(LOG_DEBUG, "Skipping window-add: Session pending for $1");
        next;
      }
      elsif ( defined $mapping{clients}{$1} ) {
        Log(LOG_DEBUG, "Skipping window-add: One or more clients attached to $1");
        next;
      }
      elsif ( $mapping{windows}{$1}{'blacklisted'} ) {

        # When a window is added to a running session, we do not know the name of the window
        # blacklisting only works when initially connecting to a session
        Log(LOG_DEBUG, "Skipping window-add: $1 is blacklisted");
        next;
      }
      elsif ( $mapping{windows}{$1}{ignore} ) {
        Log(LOG_DEBUG, "Skipping window-add: Ignore flag set for $1");
        next;
      }
      else {
        $mapping{windows}{$1}{'pending'} = 1;
        print $child_in $commandText{'ListWindows'};
        Log(LOG_DEBUG, "window-add: Spawning a terminal for $1");
        spawnTerm( $host, $sess, $1 );
        next;
      }
    }

    # Update our internal knowledge of the window name
    # Currently not really useful ...
    if ( $line =~ m/^\%window-renamed\s(@\d+)\s(.*)/ ) {
      Log(LOG_DEBUG, "Running $commandText{'ListWindows'}");
      print $child_in $commandText{'ListWindows'};
      next;
    }

    # Update our client <> window map - two clients likely point to a single window
    if ( $line =~ m/^\%session-window-changed\s(\$\d+)\s(\@\d+)/ ) {
      Log(LOG_DEBUG, "Running $commandText{'ClientMap'}");
      print $child_in $commandText{'ClientMap'};
      next;
    }

    # Produced when a client attaches to a session,
    # %client-session-changed /dev/pts/10 $163 penthe-global-session-1545894242-319412-45
    # This is probably a useless event to process
    if ( $line =~ m/^\%client-session-changed\s(.*)\s(\$\d+)\s([\w-]+)/ ) {
      Log(LOG_DEBUG, "Running $commandText{'ClientMap'}");
      print $child_in $commandText{'ClientMap'};
      next;
    }

    # Produced when a client attaches or detaches
    # This is probably a useless event to process
    if ( $line =~ m/^%sessions-changed/ ) {
      Log(LOG_DEBUG, "Running $commandText{'ClientMap'}");
      print $child_in $commandText{'ClientMap'};
      next;
    }

    # Produced when a window is closed, e.g. exit from a shell
    # Kill all attached sessions viewing that window
    if ( $line =~ m/^%unlinked-window-close\s(@\d+)/ ) {
      next unless exists $mapping{clients}{$1};
      while ( @{ $mapping{clients}{$1} } ) {
        my $client = pop @{ $mapping{clients}{$1} };
        Log(LOG_DEBUG, "Killing session $client, window $1 close");
        print $child_in $commandText{'KillClient'} . "$client\n";
      }
      delete $mapping{clients}{$1};
      delete $mapping{windows}{$1};
      print $child_in $commandText{'ListWindows'};
      print $child_in $commandText{'ClientMap'};

    }
  }
  MAINEND:
  $passcount = 1;
  exit unless ( ( $config->{reconnect} ) or not ( $config->{exitlast} ) );
}

END {
  Log(LOG_DEBUG, "END reached in $$");
  exit if $noclean;
  CleanExit;
}

sub CleanExit {
  Log(LOG_DEBUG, "END reached in $$");
  exit if $noclean;

  unlink $config->{command};
  unlink $config->{pidfile};
  exit;
}

# Load our default config file / user defined
# Define other control values used throughout the multiverse
sub LoadConfig {
  undef $config;

  %defaultOptions = (
    "detach"          => 0,
    "killrc"          => 0,
    "pauserc"         => 0,
    "reconnect"       => 1,
    "closeas"         => 0,
    "background"      => 0,
    "log_facility"    => "",
    "log_level"       => LOG_ALERT,
    "exitlast"        => 0,
    "terminal"        => [ qw(xterm) ],
    "ssh_args"        => [ qw() ],
    "alive_interval"  => 3,
    "alive_count"     => 2,
    "conn_timeout"    => 3,
    "persist"         => "10s",
    "selector"        => [ qw(rofi -dmenu -i) ],
    "tmux_bin"        => "tmux",
  );

  # Read in the config file
  if ( -e $configfile ) {
    $config = do($configfile) or die $!;
  }
  else {
    $config->{temp}     = join('/', ( $ENV{'HOME'}, qw(.tmuxc) ));
  }

  # strip a trailing slash if present, thanks Brian D Foy
  #$config->{temp} =~ s|/\z||;
 
  # Add a trailing slash, so joins are easier
  $config->{temp} =~ s|/*$|/|;

  # Set our hostname config key
  my $chost = defined($cli{host}) ? $cli{host} : "localhost";
  $config->{chost} = $chost; 

  # Set our $host
  $host = (defined($cli{host}) and ($cli{host} ne "localhost")) ? $cli{host} : undef;

  # Determine which session name takes precedence
  if ( defined($cli{session}) ) {
    # Set on the command line
    $config->{session} = $cli{session};
  } elsif ( defined( $config->{hosts}{$chost} ) ) {
    # Pick the first session under this host, sorted, that is not a config key
    foreach my $key (sort keys %{ $config->{hosts}{$chost} } ) {
      next if defined($defaultOptions{$key});
      $config->{session} = $key;
    }
  } elsif ( not defined( $config->{session} ) ) {
    # Not set at all in the config file, set a default
    $config->{session} = "global-session";
  }
  
  my $sess = $config->{session};
  my %precedence;

  # Look up a number of keys that can be set at different levels
  # If no value can be found, use a sane default
  foreach my $key (keys %defaultOptions) {
    if (defined($cli{$key})) {
      # set on the CLI
      $precedence{$key} = $cli{$key};
    } elsif (defined($config->{hosts}{$chost}{$sess}{$key})) {
      # Set for a specific host/session combo
      $precedence{$key} = $config->{hosts}{$chost}{$sess}{$key};
    } elsif (defined($config->{hosts}{$chost}{$key})) {
      # Set for a specific host
      $precedence{$key} = $config->{hosts}{$chost}{$key};
    } elsif (defined($config->{$key})) {
      # Set globally in the config
      $precedence{$key} = $config->{$key};
    } else {
      # Not defined anywhere, set our fall-back default
      $precedence{$key} = $defaultOptions{$key};
    }
    # Set the key/value in the config hash
    $config->{$key} = $precedence{$key};
  }

  # Make our temp directory and subdirectories
  mkdir $config->{temp} unless -d $config->{temp};
  my @subs = ( "ssh", "control","pid" );
  foreach my $dir (@subs) {
    my $fulldir = join('', $config->{temp}, $dir);
    mkdir $fulldir unless -d $fulldir;
  }

  # Set our hostname
  ( $config->{hostname}, undef ) = split( /\./, hostname, 2 );

  # Define our control session
  $config->{control} = join( '', ( $config->{hostname}, qw(-), $config->{session}, qw(-control) ) );

  # Define our command fifo
  $config->{command} = join( '', ( $config->{temp}, qw(control/), $config->{session}, qw(@), $config->{chost}, qw(.control) ));

  # Define our PID file
  $config->{pidfile} = join( '', ( $config->{temp}, qw(pid/), $config->{session}, qw(@), $config->{chost}, qw(.pid) ));

  %publicCommands = (
    'KillSelf'    => \&KillSelf,
    'PauseSelf'   => \&PauseSelf,
  );

  # The first field in the format string indicates the lookup key for %commandParse
  %commandText = (
    'ListWindows'   => "lsw -F 'ListWindows:#{session_group},#{window_id},#{window_name},#{window_index}' -t " . $config->{session} . "\n",
    'BulkSpawn'     => "lsc -F 'BulkSpawn:#{session_group},#{session_id},#{session_name},#{window_id}'\n",
    'BulkDetach'    => "lsc -F 'BulkDetach:#{session_group},#{session_id},#{session_name},#{window_id}'\n",
    'ClientMap'     => "lsc -F 'ClientMap:#{session_group},#{session_id},#{session_name},#{window_id},#{window_name}'\n",
    'KillClient'    => "kill-session -t ",
  );

  %commandParse = (
    'ListWindows' => \&ListWindows,
    'BulkSpawn'   => \&BulkSpawn,
    'BulkDetach'  => \&BulkDetach,
    'ClientMap'   => \&ClientMap,
  );

  Log(LOG_DEBUG, "Run-time configuration");
  Log(LOG_DEBUG, \$config);
}

# Simple command dispatcher, InjectCommand picks/prompts for the session
sub Menu {
  my %menu = (
    'Create New Window'      => 'new-window -d',
    'Detach Session Windows' => 'tmuxc BulkDetach',
    'Kill Control Daemon'    => 'tmuxc KillSelf',
    'Open All Windows'       => 'tmuxc BulkSpawn',
  );

  my ( $child_out, $child_in );
  my $pid = open2( $child_out, $child_in, @{ $config->{selector} } );

  foreach my $item ( sort keys %menu ) {
    print $child_in "$item\n";
  }
  close($child_in);
  my $option = <$child_out>;
  exit unless defined($option);
  chomp($option);
  InjectCommand( $menu{$option} );
  exit;
}

sub InstanceCheck {

  # Generate a list of instances from config file 
  my ( @check, $instances );
  foreach my $host ( sort keys %{ $config->{hosts} } ) {
    foreach my $session ( sort keys %{ $config->{hosts}{$host} } ) {
      # Skip if this is an option name / reserved word
      next if defined($defaultOptions{$session});
      push @check, "$session\@$host";
    }
  }

  # Check each instance defined in config file
  for my $session (@check) {
    my $control = join( '', ( $config->{temp}, qw(control/), $session , ".control" ));
    my $pidfile = join( '', ( $config->{temp}, qw(pid/), $session , ".pid" ));
    if ( -f $pidfile ) {
      open PID, '<', $pidfile;
      my $pid = <PID>;
      close PID;

      my $running = kill( 0, $pid );
      if ($running) {
        push @{ $instances->{running} }, $session;
      } else {
        push @{ $instances->{dead} }, $session;
      }
    } else {
      push @{ $instances->{dead} }, $session;
    }
  }

  my $cglob     = join( '', ( $config->{temp}, qw(control/), "*.control" ));
  my @controls  = glob($cglob);


  for my $control (@controls) {
    my $filename = basename($control);
    $filename =~ s/\.control//;

    my $pidfile = $control;
    $pidfile =~ s/control/pid/g;

    if ( -f $pidfile ) {
      open PID, '<', $pidfile;
      my $pid = <PID>;
      close PID;

      my $running = kill( 0, $pid );
      if ($running) {
        unless ( grep { $_ eq $filename } @{ $instances->{running} } ) {
          push @{ $instances->{running} }, $filename;
        }
      } else {
        # If the pid isn't running, this is a one-off session that somehow lingered on
        # Remove the pidfile and the control socket
        unlink $pidfile;
        unlink $control;
      }
    } else {
      # No pidfile associated with this control socket, purge it
      unlink $control;
    }
  }
  return $instances;
}

# Determine which control sessions are running, prompt for anything else
sub Launcher {
  my ( @dead, $child_out, $child_in );

  my $instances = InstanceCheck;

  if (defined($instances->{dead})) {
    @dead = @{ $instances->{dead} };
  }

  my $response;
  if ( scalar(@dead) > 0 ) {
    my $pid = open2( $child_out, $child_in, @{ $config->{selector} } );
    for (@dead) {
      my ( $sess, $host ) = split( '@', $_, 2 );
      print $child_in "$sess\@$host\n";
    }
    close($child_in);
    $response = <$child_out>;
    close($child_out);
  } else {
    exit;
  }
  exit unless defined($response);
  chomp($response);

  my ( $sess, $host ) = split( /@/, $response, 2 );
  my $myself = join( '/', ( $RealBin, $RealScript ) );
  my $cmd;
  if ( $host eq "localhost" ) {
    $cmd = join( ' ', ( $myself, qw(-s), $sess, qw(-b) ) );
  }
  else {
    $cmd = join( ' ', ( $myself, qw(-h), $host, qw(-s), $sess, qw(-b) ) );
  }

  my $fpid = fork;
  if ( $fpid == 0 ) {
    exit 255 unless open STDIN,  '/dev/null';
    exit 255 unless open STDOUT, '>/dev/null';
    exit 255 unless open STDERR, '>/dev/null';
    setsid();
    $fpid = fork;
    if ( $fpid == 0 ) {
      $noclean = 0;
      exec($cmd);
    }
    $noclean = 1;
    exit;
  }
  waitpid( $fpid, 0 );
  $noclean = 1;
  exit;
}

# If there's only one control session, inject a command into that FIFO
# If there are multiple, prompt via rofi

sub InjectCommand {
  my $command = shift;

  Log(LOG_DEBUG, "InjectCommand: $command");

  my $instances = InstanceCheck;

  my @sessions;
  if (defined($instances->{running})) {
    @sessions = @{ $instances->{running} };
  } else {
    exit;
  }
  my @sessmenu;

  # An exact host and session were provided
  if ($cli{host} and $cli{session}) {
    my $session = join( '', $cli{session}, qw(@), $cli{host} );
    if ( grep { $_ eq $session } @sessions ) {
      push @sessmenu, $session;
    }
  # Find all hosts that match what was provided on the CLI
  } elsif ($cli{host}) {
    for (@sessions) {
      if ($_ =~ m/$cli{host}/) {
        push @sessmenu, $_
      }
    }
  # Find all sessions that match what was provided on the CLi
  } elsif ($cli{session}) {
    for (@sessions) {
      if ($_ =~ m/$cli{session}/) {
        push @sessmenu, $_
      }
    }
  # Nothing provided, prompt with all running hosts/sessions
  } else {
    @sessmenu = @sessions;
  }

  # I really should learn splice some day
  if (($command =~ m/new-window/)
    and (not defined($cli{host}))
    and (not defined($cli{session}))) {
    my @clean;
    for (@sessmenu) {
      my ( $sess, $host ) = split( '@', $_, 2 );
      unless ($config->{hosts}{$host}{$sess}{skipnw}) {
        push @clean, $_;
      }
    }
    @sessmenu = @clean;
  }

  # Generate a menu / or pick if there's only one session
  my ( $response, $session );
  if ( scalar(@sessmenu) > 1 ) {
    my ( $child_out, $child_in );
    my $pid = open2( $child_out, $child_in, @{ $config->{selector} } );

    for (@sessmenu) {
      my ( $sess, $host ) = split( '@', $_, 2 );
      print $child_in "$sess\@$host\n";
    }
    close($child_in);

    $session = <$child_out>;
    exit unless defined($session);
    chomp($session);
  } elsif ( scalar(@sessmenu) == 1) {
    $session = shift @sessmenu;
  } else {
    Log(LOG_NOTICE, "No running sessions");
    exit;
  }

  my $control = join( '', ( $config->{temp}, qw(control/), $session , ".control" ));
  my $pidfile = join( '', ( $config->{temp}, qw(pid/), $session , ".pid" ));

  Log(LOG_DEBUG, "PID file is $pidfile");
  Log(LOG_DEBUG, "Control file is $control");

  my $pid;
  if ( -f $pidfile ) {
    open PID, '<', $pidfile;
    $pid = <PID>;
    close PID;
  }

  unless ( kill( 0, $pid ) ) {
    print "$pid not running exiting!";
    exit;
  }

  open CONTROL, '>', $control;
  print CONTROL "$command";
  close CONTROL;

  # This sleep is actually important!
  # With out it, there's a chance the USR1 handler won't read
  # anything from the control fifo ... fuck.

  sleep 0.5;
  kill( 'USR1', $pid );
  exit;
}

sub shellQuote {
  my @return;

  for my $group (@_) {
    my @args = @$group;
    for (@args) {
      s/'/'"'"'/g;
    }
    push @return, join ' ', map { /^[-\/|@=_0-9a-z]+$/i ? $_ : qq{'$_'} } @args;
  }

  return join '|', @return;
}

# Wraps a given command with SSH when a remote host is defined
sub buildCommand {
  my $remote = shift;
  return @{ $_[0] } unless $remote;

  my $cpath = join('', $config->{temp}, qw(ssh/%C) );
  my @cmd =
    grep { length }
    qw(ssh -q -t), @{ $config->{ssh_args} }, qw(-S), $cpath, $remote, shellQuote(@_);

  return @cmd;
}

# Write out a custom shell script and launch it with our terminal
sub spawnTerm {
  my ( $host, $session, $window ) = @_;
  my ( undef, $id ) = split( '@', $window );
  my ( $sec, $usec ) = gettimeofday();
  my $clone_session = $config->{hostname} . "-$session-$sec-$usec-$id";

  my @cmd = buildCommand(
    $host,
    [
      $config->{tmux_bin},
      qw(new-session -d -t),
      $session,
      qw(-s),
      $clone_session,
    ]
  );
  my $clone_command = join( ' ', @cmd );

  @cmd = buildCommand(
    $host,
    [
      $config->{tmux_bin},
      qw(attach-session -t),
      $clone_session,
      qw(\; set-option destroy-unattached on),
      qw(\; select-window -t),
      $window,
    ]
  );
  my $attach_command = join( ' ', @cmd );

  my $script       = join( '', ( $config->{temp}, $clone_session));
  my $start_script = qq|#!/bin/sh
test -f $script && rm $script
$clone_command
exec $attach_command
|;

  open SCRIPT, '>', $script;
  print SCRIPT $start_script;
  close SCRIPT;
  chmod 0755, $script;

  my @exec = @{ $config->{terminal} };
  push @exec, $script;
  Log(LOG_DEBUG, "Terminal spawn command");
  Log(LOG_DEBUG, \@exec);
  my $fpid = fork;
  if ( $fpid == 0 ) {
    exit 255 unless open STDIN,  '/dev/null';
    exit 255 unless open STDOUT, '>/dev/null';
    exit 255 unless open STDERR, '>/dev/null';
    setsid();
    $fpid = fork;
    if ( $fpid == 0 ) {
      exec @exec;
    }
    $noclean = 1;
    exit;
  }
  waitpid( $fpid, 0 );
  return;
}

# Return 1 if blacklisted, 0 if not
sub checkIfBlacklisted {
  my $window = shift;
  Log(LOG_DEBUG, "Checking if $window is blacklisted on $config->{chost}");

  my $chost = $config->{chost};
  my $sess  = $config->{session};

  if ( defined( $config->{hosts}{$chost}{$sess}{blacklist} ) ) {
    if ( grep { $_ eq $window } @{ $config->{hosts}{$chost}{$sess}{blacklist} } ) {
      Log(LOG_DEBUG, "Blacklisted window: $window");
      return 1;
    }
  }
  return 0;
}

# List every window, set the blacklisted flag where appropriate
sub ListWindows {
  my $block = shift;
  for my $entry ( @{$block} ) {
    my ( $group, $id, $name, $wid ) = split( ',', $entry );
    $mapping{windows}{$id}{'name'}  = $name;
    $mapping{windows}{$id}{'index'} = $wid;
    $mapping{windows}{$id}{'blacklisted'} =
      ( checkIfBlacklisted($name) ) ? 1 : 0;
  }
  Log(LOG_DEBUG, "ListWindows end");
  Log(LOG_DEBUG, \%mapping);
}

# Detach all clients from all windows, leaving everything else running
# This will NOT mark a window as ignored
sub BulkDetach {
  my $block    = shift;
  my $child_in = shift;

  Log(LOG_DEBUG, "BulkDetach start"); 
  Log(LOG_DEBUG, \%mapping );

  for my $entry ( @{$block} ) {
    my ( $group, $sid, $name, $wid ) = split( ',', $entry );

    # Filter for our specific session group
    next unless $config->{session} eq $group;

    # Filter out our control session
    next if $config->{control} eq $name;

    Log(LOG_INFO, "Detaching terminal from $sid");
    print $child_in $commandText{'KillClient'} . "$sid\n";
  }
}

# Spawn a terminal for all non-blacklisted windows
sub BulkSpawn {
  my $block    = shift;
  my $child_in = shift;

  Log(LOG_DEBUG, "BulkSpawn start");
  Log(LOG_DEBUG, \%mapping);

  for my $entry ( @{$block} ) {
    my ( $group, $sid, $name, $wid ) = split( ',', $entry );

    # Filter for our specific session group
    next unless $config->{session} eq $group;

    # Filter out our control session
    next if $config->{control} eq $name;

    # Filter for our hostname in the linked session name
    next unless $name =~ m/$config->{hostname}/;

    # Don't push duplicate session ids
    unless ( grep { $_ eq $sid } @{ $mapping{clients}{$wid} } ) {
      push @{ $mapping{clients}{$wid} }, $sid;
    }
  }

  foreach my $window ( keys %{ $mapping{windows} } ) {
    if ( exists $mapping{clients}{$window} ) {
      next;
    }
    else {
      unless ( checkIfBlacklisted( $mapping{windows}{$window}{name} ) ) {
        Log(LOG_INFO, "Spawning a terminal for $window"); 
        delete $mapping{clients}{$window};
        $mapping{windows}{$window}{'pending'} = 1;
        spawnTerm( $host, $config->{session}, $window );
      }
    }
  }
  Log(LOG_DEBUG, "BulkSpawn end");
  Log(LOG_DEBUG, \%mapping);
}

# Build a map of all windows and the clients viewing the window
# If a client was viewing a window but has been closed, mark that window as ignored
# Future open-all commands will skip that window while the same tmuxc controller is running
sub ClientMap {
  my $block    = shift;
  my $child_in = shift;
  my $sess     = $config->{session};
  my @found_windows;

  Log(LOG_DEBUG, "ClientMap start");
  Log(LOG_DEBUG, \%mapping );

  # Purge existing mappings
  my %previous = %mapping{clients};
  delete $mapping{clients};

  # Regenerate client <> window mappings
  for my $entry ( @{$block} ) {
    my ( $group, $sid, $name, $wid, $wname ) = split( ',', $entry );

    # Filter for our specific session group
    next unless $config->{session} eq $group;

    # Filter out our control session
    next if $config->{control} eq $name;

    # Filter for our hostname in the linked session name
    next unless $name =~ m/$config->{hostname}/;

    # This is a session we control, attached to a window
    push @{ $mapping{clients}{$wid} }, $sid;
    $mapping{windows}{$wid}{'name'} = $wname;

    # This is no longer pending, a session is pointed to it
    delete $mapping{windows}{$wid}{'pending'};
    push @found_windows, $wid;
  }

  foreach my $window ( keys %{ $previous{clients} } ) {
    unless ( defined( $mapping{clients}{$window} ) ) {
      Log(LOG_INFO, "Setting ignore flag for $window");
      $mapping{windows}{$window}{ignore} = 1;
    }
  }

  Log(LOG_DEBUG, "ClientMap end");
  Log(LOG_DEBUG, \%mapping );

  if ($config->{closeas}) {
    my $close = 1;
    foreach my $win (keys %{ $mapping{windows} }){
      next if (defined $mapping{windows}{$win}{ignored} and $mapping{windows}{$win}{ignored});
      next if (defined $mapping{windows}{$win}{blacklisted} and $mapping{windows}{$win}{blacklisted});
      next if (defined $mapping{clients}{$win});
      
      # We aren't done spawning windows, so don't exit yet
      $close = 0;
    }

    if ($close) {
      exit;
    }
  }
}

sub PauseSelf {
  $pause ^= 1;
}

sub KillSelf {
  exit;
}

sub Log {
  my $level = shift;
  my $entry = shift;

  chomp($entry);
  if ($level le $config->{log_level}) {
    if ($config->{log_level} == LOG_DEBUG) {
      unless ( ref($entry)) {
        syslog($config->{log_level}, "%s", $entry);
        print STDERR "## $entry\n";
      } else {
        print STDERR Dumper($entry);
      }
      return;
    }
    else {
      syslog($config->{log_level}, "%s", $entry);
      print STDOUT "$entry\n";
      return;
    }
  }
}

__END__

=head1 NAME

B<tmuxc> - TMUX terminal manager

=head1 SYNOPSIS

B<tmuxc> [options]

=head1 OPTIONS

=over 4

=item B<--host|h>

Connect to a tmux instance on the listed host.

=item B<--session|s>

Attach to the listed tmux session.

=item B<--background|b>

After connecting to a host and instance, background the daemon.

=item B<--config|c>

Use the specified configuration file, overriding the default location of F<~/.tmuxc.conf>.

=item B<--detach|d>

After connecting to a host and instance, detach any clients connected to the session.

=item B<--verbose|v>

Enable verbose/debugging mode to print extra details.

=item B<--killrc|k>

After connecting to a remote host, kill the remote tmuxc instance monitoring our session.

=item B<--reconnect|R>

Reconnect to a remote host via SSH if the connection drops. This is enabled by default. This option overrides a host/session specific disable flag.

=item B<--closeas|C>

Exit the control daemon after spawning terminals for every window.

=item B<--exitlast|E>

Exit the control daemon after the last windown in the tmux session is closed.

=item B<--new|n>

Create a new window for the specified tmux session on the specified host.

=item B<--launcher|l>

Open up a rofi menu listing sessions from the .tmuxc.conf file that aren't running.

=item B<--menu|m>

Open up a rofi menu listing control options. If one instance is running, the command is executed on that instance. If multiple are running, prompt the running sessions.

=item B<--exit|e>

Tell a specified tmuxc instance to exit.

=item B<--pause|p>

Tell a specified tmuxc instance to toggle it's pause mode. When in pause mode, all tmux messages received are ignored, as are any commands sent to the FIFO or on the command line.

=item B<--raw|r>

Issue a raw tmux or tmuxc command to a specified instance.

=back

=head1 EXAMPLES

Connect to a session labeled I<global-session> on the host I<shellhost>, then background.

  tmuxc -h shellhost -s global-session -b

Connect to the default session on localhost, then background.

  tmuxc -b

Issue the raw tmux command I<new-window -d> to the default session on localhost.

  tmuxc -r 'new-window -d'

=head1 SCRIPTING

Each running instance of tmuxc creates a command FIFO that can be used to control tmux and tmuxc. The FIFO takes the form of F<hostname-session.control>, and by default is available in F<~/.tmuxc/control/>. Once you've written a command to the FIFO, send the B<USR1> signal to tmuxc. The PID is available in F<~/.tmuxc/pid/hostname-session.pid>. 

See B<RAW COMMANDS> for examples. 

=head1 RAW COMMANDS

Raw commands can take multiple forms. Commands prefaced with I<tmuxc> hit the internal
command dispatcher. Any other command is passed as-is to tmux. Most tmuxc commands are
of no real use to end-users.

=head2 EXAMPLES

  tmuxc PauseSelf
  new-window -d

=head2 TMUXC INTERNAL COMMANDS

=over 6

=item B<BulkSpawn>

Instruct tmuxc to spawn terminals for all windows that do not have an attached client.

=item B<BulkDetach>

Instruct tmuxc to close all clients attached to windows.

=item B<KillSelf>

Instruct tmuxc to cleanly exit.

=item B<PauseSelf>

Instruct tmuxc to ignore all input from the command line and from tmux, until this 
option is toggled again.

=back

=head1 AUTHOR

Zach Dykstra <dykstra.zachary@gmail.com>

=cut
